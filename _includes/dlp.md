这次实验不用什么示例，这里只提供模幂运算和基于cado-nfs的离散对数计算供大家参考。如果大家需要更多的示例可以私戳助教。

## 1. 实验参数

- p(模) = 31050371851708889440695779044384182719244728783
- target = 13821904325547285207847180361637528630753679004
- q(子群的阶) = 11706593258111142827
- g(底数) = Hash(学号)的2\*1097\*1208925819614629174706189=2652383248234496409305378666次方

**求解模p下以g为底target的离散对数。**

## 2. 模幂运算

下面的示例提供对`x^y mod z`的计算。本质就是调用Python的`pow(x, y, z)`函数实现。这里放出来用来方便大家计算学号散列值的2\*1097\*1208925819614629174706189=2652383248234496409305378666次方，以及验证求解出来的离散对数是否正确。

{% include dlp/calc_pow_mod.html %}

## 3. cado-nfs离散对数计算

下面是利用cado-nfs计算模p下的离散对数`log_g(target)`。其中`p`和`target`是实验给定的参数，`g`为学号散列值的`2*1097*1208925819614629174706189=2652383248234496409305378666`次方。使用示例前，**务必先计算好`g`**，而不是直接传学号或者学号的散列值。

cado-nfs可以在90秒左右计算出实验要求的离散对数，相比pollard-rho算法效率要高不少。下方的cado-nfs计算**并非实时地在服务器端计算，而是加入到任务队列中，转发给一台性能较强的电脑中进行计算，计算完毕后再通知服务器拉取结果**。因此，在下方输入`g`之后，不会立即出现结果，需要排队等待一段时间后，再输入相同的`g`观察任务是否已经完成，如果完成，结果框会给出离散对数计算结果或者错误的理由。如果长时间任务还没响应，请联系助教。

**该离散对数计算结果仅供对比参考，实验还是需要使用pollard-rho计算离散对数**

计算DLP的机器性能：
- CPU: AMD Ryzen 7 3700X
- 内存: 32GB DDR4 3000Mhz
- 操作系统：Ubuntu 20.04(Windows 10下的WSL子系统)
- cado-nfs版本: 2.3 [Gitlab](https://gitlab.inria.fr/cado-nfs/cado-nfs) Master分支
- Python版本: 3.8

{% include dlp/cado_nfs.html %}